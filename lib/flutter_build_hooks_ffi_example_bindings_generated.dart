// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// A very short-lived native function.
///
/// For very short-lived functions, it is fine to call them on the main isolate.
/// They will block the Dart execution while running the native function, so
/// only do this for native functions which are guaranteed to be short-lived.
@ffi.Native<ffi.IntPtr Function(ffi.IntPtr, ffi.IntPtr)>()
external int sum(int a, int b);

/// A longer lived native function, which occupies the thread calling it.
///
/// Do not call these kind of native functions in the main isolate. They will
/// block Dart execution. This will cause dropped frames in Flutter applications.
/// Instead, call these native functions on a separate isolate.
@ffi.Native<ffi.IntPtr Function(ffi.IntPtr, ffi.IntPtr)>()
external int sum_long_running(int a, int b);

/// --- tree-sitter demo --------------------------------------------------------
///
/// The returned string is heap-allocated; release it by calling [ts_free].
///
/// language:
/// 0 = C
/// 1 = JavaScript
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, ffi.Int32)>()
external ffi.Pointer<ffi.Char> ts_parse_sexp(
  ffi.Pointer<ffi.Char> utf8_source,
  int language,
);

/// Returns newline-delimited tokens for [utf8_source]. Each line is:
/// <start_byte>\t<end_byte>\t<named:0|1>\t<node_type>\n
///
/// The returned string is heap-allocated; release it by calling [ts_free].
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, ffi.Int32)>()
external ffi.Pointer<ffi.Char> ts_tokens(
  ffi.Pointer<ffi.Char> utf8_source,
  int language,
);

/// Frees memory returned by this library (e.g. [ts_parse_sexp]).
@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>()
external void ts_free(ffi.Pointer<ffi.Void> ptr);
