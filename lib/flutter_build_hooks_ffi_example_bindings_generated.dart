// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// A very short-lived native function.
///
/// For very short-lived functions, it is fine to call them on the main isolate.
/// They will block the Dart execution while running the native function, so
/// only do this for native functions which are guaranteed to be short-lived.
@ffi.Native<ffi.IntPtr Function(ffi.IntPtr, ffi.IntPtr)>()
external int sum(int a, int b);

/// A longer lived native function, which occupies the thread calling it.
///
/// Do not call these kind of native functions in the main isolate. They will
/// block Dart execution. This will cause dropped frames in Flutter applications.
/// Instead, call these native functions on a separate isolate.
@ffi.Native<ffi.IntPtr Function(ffi.IntPtr, ffi.IntPtr)>()
external int sum_long_running(int a, int b);

/// --- tree-sitter demo --------------------------------------------------------
///
/// The returned string is heap-allocated; release it by calling [ts_free].
///
/// language:
/// 0 = C
/// 1 = JavaScript
/// 2 = Dart
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, ffi.Int32)>()
external ffi.Pointer<ffi.Char> ts_parse_sexp(
  ffi.Pointer<ffi.Char> utf8_source,
  int language,
);

/// Returns newline-delimited tokens for [utf8_source]. Each line is:
/// <start_byte>\t<end_byte>\t<named:0|1>\t<node_type>\n
///
/// The returned string is heap-allocated; release it by calling [ts_free].
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, ffi.Int32)>()
external ffi.Pointer<ffi.Char> ts_tokens(
  ffi.Pointer<ffi.Char> utf8_source,
  int language,
);

/// Runs a tree-sitter query and returns newline-delimited captures.
///
/// Each line is:
/// <start_byte>\t<end_byte>\t<capture_name>\n
///
/// The returned string is heap-allocated; release it by calling [ts_free].
@ffi.Native<
  ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.Char>,
    ffi.Int32,
    ffi.Pointer<ffi.Char>,
  )
>()
external ffi.Pointer<ffi.Char> ts_query_captures(
  ffi.Pointer<ffi.Char> utf8_source,
  int language,
  ffi.Pointer<ffi.Char> utf8_query,
);

/// Frees memory returned by this library (e.g. [ts_parse_sexp]).
@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>()
external void ts_free(ffi.Pointer<ffi.Void> ptr);

/// --- tree-sitter incremental document API -----------------------------------
@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Int32)>()
external ffi.Pointer<ffi.Void> ts_doc_new(int language);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>()
external void ts_doc_delete(ffi.Pointer<ffi.Void> doc);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<ffi.Void>,
    ffi.Uint32,
    ffi.Uint32,
    ffi.Uint32,
    ffi.Uint32,
    ffi.Uint32,
    ffi.Uint32,
    ffi.Uint32,
    ffi.Uint32,
    ffi.Uint32,
  )
>()
external void ts_doc_edit(
  ffi.Pointer<ffi.Void> doc,
  int startByte,
  int oldEndByte,
  int newEndByte,
  int startRow,
  int startCol,
  int oldEndRow,
  int oldEndCol,
  int newEndRow,
  int newEndCol,
);

@ffi.Native<ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>()
external int ts_doc_reparse(ffi.Pointer<ffi.Void> doc, ffi.Pointer<ffi.Char> utf8Source);

@ffi.Native<
  ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)
>()
external ffi.Pointer<ffi.Char> ts_doc_query_captures(
  ffi.Pointer<ffi.Void> doc,
  ffi.Pointer<ffi.Char> utf8Query,
);
